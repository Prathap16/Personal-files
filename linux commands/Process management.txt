MANAGING PROCESS
? A Linux process is a program running in the Linux system. Depending on Linux distributions, it's also known as service. In Linux community however, a Linux process is called daemon.
? When you start a program or running an application in Linux, you actually execute that program. A Linux process (a daemon), running in foreground or in the background, uses memory and CPU resources. That's why we need to manage Linux process. Keeping unused Linux process running in the system is a waste and also exposes your system to security threat.
? In Linux, every running process or daemon is given an identity number called PID (Process ID). The process id is unique. We can terminate unused program in the system by stopping its process id.
? In order to manage Linux processes, we need to identify some process information such as who's responsible for the process, which terminal the process is running from and what command used to run the process.

LAB WORK:-
To monitor the process using ps command
? The ps command gives the running process of the present terminal and present command. The syntax for ps command is
#ps
To see total number of processes running in the system
? The possible options which can be used with ps command are
#ps –a
To see the processes running by the logged in user (ex root)
? #ps –u <user name>
#ps –u musab
#ps -u ( if no name is given it will show the processes of the logged in user)
To see which process are attached with some terminals (tty) and which are not
? #ps –x
To see the offline process of the system, already executed
? #ps –aux

Signals in Linux
? Signals are a way of sending simple messages to processes. Most of these messages are already defined and can be found in <linux/signal.h>. However, signals can only be processed when the process is in user mode. If a signal has been sent to a process that is in kernel mode, it is dealt with immediately on returning to user mode.
? Every signal has a unique signal name, an abbreviation that begins with SIG (SIGINT for interrupt signal, for example). Each signal name is a macro which stands for a positive integer - the signal number for that kind of signal. Your programs should never make assumptions about the numeric code for a particular kind of signal, but rather refer to them always by the names defined. This is because the number for a given kind of signal can vary from system to system, but the meanings of the names are standardized and fairly uniform.
? Signals can be generated by the process itself, or they can be sent from one process to another. A variety of signals can be generated or delivered, and they have many uses for programmers. (To see a complete list of signals in the Linux® environment, uses the command kill -l

The most common signals used are
? 1 for reloading the process
? 9 for killing the process
? 15 for Terminating the process
? 20 for stopping the process
To kill the signal completely
? To kill the signal
? First find out the process running in the system, let’s say by a user
#ps –u <user name>
#ps –u musab
#kill <signal no> <process id>
#kill -9 11591
Likewise you can use other signals to kill the process like
#kill -15 <pid>
#kill -1 <pid>
To stop the process using a signal no. 20
? To stop a process first login as a normal user and start a process
#su – musab
#cat > hello
? Check its pid and kill it by using 20, #ps –u musab
#kill -20
? check its effect at the user’s console
? Restart the process continue working
#fg <pid>
#fg 1

Setting up the Priority of a Process
? When talking about processes priority is all about managing processor time. The Processor or CPU is like a human juggling multiple tasks at the same time. Sometimes we can have enough room to take on multiple projects. Sometimes we can only focus on one thing at a time. Other times something important pops up and we want to devote all of our energy into solving that problem while putting less important tasks on the back burner.
? In Linux we can set guidelines for the CPU to follow when it is looking at all the tasks it has to do. These guidelines are called niceness or nice value. The Linux niceness scale goes from -20 to 19. The lower the number the more priority that task gets. If the niceness value is high number like 19 the task will be set to the lowest priority and the CPU will process it whenever it gets a chance. The default nice value is zero.
? By using this scale we can allocate our CPU resources more appropriately. Lower priority programs that are not important can be set to a higher nice value, while high priority programs like daemons and services can be set to receive more of the CPU’s focus. You can even give a specific user a lower nice value for all of his/her processes so you can limit their ability to slow down the computer’s core services.
? There are two options to reduce/increase value of a process. You can either do it using the nice command or the renice command.
LAB WORK:-
To schedule a priority of a process before starting it
? To set a priority to a process before starting it, the syntax is
#nice –n <nice value range (-20 to 19)> <command>
#nice –n 5 cat > ktfile
? Log in to other terminal and check the nice value for the above command/ process.
#ps –elf

To change the nice value of any process while it is running.
? To reschedule the nice value of existing process, first check the PID of that process by running #ps –elf command.
? As from previous task we know the PID of cat command i.e. 13155
? Use the following command to renice the value of a cat command which is still running
#renice <nice value (-20 to 19)> <PID>
#renice 2 13155

Monitoring the process using top command
? When you need to see the running processes on your Linux in real time, you have top as your tool for that.
? top also displays other info besides the running processes, like free memory both physical and swap
Monitoring all process using top command
? To monitor all processes in the system use the following command
#top
The first line in top:
? “02:23:18? is the current time; “up 1 day” shows how long the system has been up for; “
3 user” how many users are logged in; “load average: 0.01, 0.00, 0.23? the load average of the system (1minute, 5 minutes, 15 minutes).

The second line in top:
? Shows the number of processes and their current state.
The third line in top:
? Shows CPU utilization details. “9.5%us” user processes are using 9.5%; “31.2%sy” system processes are using 31.2%; “27.0%id” percentage of available cpu; “7.6%wa” time CPU is waiting for IO.
The fourth and fifth lines in top:
? “543948k total” is total memory in the system; “526204K used” is the part of the RAM that currently contains information; “17744k free” is the part of RAM that contains no information; “17748K buffers and 129928k cached” is the buffered and cached data for IO.
By default, top starts by showing the following task's property:
Field Description
PID
Process ID
USER
Effective User ID
PR
Dynamic priority
NI
Nice value, also known as base priority
VIRT
Virtual Size of the task. This includes the size of process's executable binary, the data area and all the loaded shared libraries.
RES
The size of RAM currently consumed by the task. Swapped out portion of the task is not included.
SHR
Some memory areas could be shared between two or more task, this field reflects that shared areas. The example of shared area are shared library and SysV shared memory.
S
Task status
%CPU
The percentage of CPU time dedicated to run the task since the last top's screen update.
%MEM
The percentage of RAM currently consumed by the task.
TIME+
The total CPU time the task has been used since it started. "+" sign means it is displayed with hundredth of a second granularity. By default, TIME/TIME+ doesn't account the CPU time used by the task's dead children.
Command
Showing program names

Interacting with TOP
Now that we are able to understand the output from TOP lets learn how to change the way the output is displayed.
Just press the following key while running top and the output will be sorted in real time.
? M – Sort by memory usage
? P – Sort by CPU usage
? T – Sort by cumulative time
? z – Color display
? k – Kill a process
? q – quit
? r – to renice a process
? h - help
To kill the process with PID 21, then press “k” and a prompt will ask you for the PID number, and enter 21. When asked about singal number give 9 or 15